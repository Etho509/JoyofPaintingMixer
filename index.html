<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GirthyCatboy’s Color Mixer for Joy of Painting</title>
  <style>
    :root { --bg:#0b0f14; --panel:#121923; --muted:#8aa0b2; --text:#e7eef6; --acc:#2563eb; }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#0b0f14,#0e141c 40%,#0b0f14);color:var(--text);font:16px/1.45 Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{max-width:1100px;margin:40px auto;padding:0 16px}
    .card{background:var(--panel);border:1px solid #1f2a36;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    header{display:flex;gap:14px;align-items:center;margin-bottom:18px}
    h1{font-size:20px;margin:0;font-weight:700}
    p.sub{margin:0;color:var(--muted)}
    .pane{padding:18px}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:16px}
    @media (max-width:900px){.row{grid-template-columns:1fr}}
    label{font-weight:600;font-size:14px}
    input[type="text"],input[type="number"],button,select{width:100%;padding:12px 14px;border-radius:12px;border:1px solid #223041;background:#0e1420;color:var(--text)}
    input[type="checkbox"]{transform:scale(1.1);vertical-align:middle}
    button{cursor:pointer;background:linear-gradient(180deg,#3e8cff,#2b6fe0);border:1px solid #2d6fdd;font-weight:700}
    button:disabled{opacity:.6;cursor:not-allowed}
    .swatch{width:48px;height:48px;border-radius:10px;border:1px solid #203048}
    .stack{display:flex;gap:10px;align-items:center}
    .muted{color:var(--muted)}
    .result{display:grid;grid-template-columns:1fr;gap:14px}
    .step{padding:12px 14px;border:1px dashed #2a3b52;border-radius:12px;background:#0c131e}
    code{background:#0f1625;border:1px solid #1f2a36;border-radius:8px;padding:2px 6px}
    .pill{display:inline-block;padding:4px 10px;border-radius:999px;border:1px solid #2a3b52;background:#0c131e;margin:2px 6px 2px 0}
    footer{opacity:.85;font-size:12px}
    .grid-3{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="pane">
        <header>
          <div class="swatch" id="targetSwatch" title="Target"></div>
          <div>
            <h1>GirthyCatboy’s Color Mixer for Joy of Painting</h1>
            <p class="sub">Enter a hex color. The app finds dye steps that approximate it using Minecraft’s dye averaging on a <b>white canvas base</b>. Includes optional IRL mode and snap‑to‑dye.</p>
          </div>
        </header>

        <div class="row">
          <div>
            <label for="hex">Target Hex</label>
            <input id="hex" type="text" placeholder="#2563EB" value="#2563EB" />
          </div>
          <div>
            <label>&nbsp;</label>
            <button id="run">Compute Recipe</button>
          </div>
        </div>

        <div class="row" style="margin-top:12px">
          <div>
            <label>Search Depth</label>
            <div class="grid-3">
              <div>
                <span class="muted">One‑step: max dyes</span>
                <input id="d1" type="number" min="1" max="6" value="4" />
              </div>
              <div>
                <span class="muted">Two‑step: max dyes/step</span>
                <input id="d2" type="number" min="1" max="5" value="3" />
              </div>
              <div>
                <span class="muted">Use two‑step search</span>
                <div><input id="enableTwo" type="checkbox" checked> <label for="enableTwo" class="muted">Enabled</label></div>
              </div>
            </div>
          </div>
          <div>
            <label>Optional ΔE cutoff</label>
            <div class="stack">
              <input id="deltaCutoff" type="number" step="0.1" min="0" placeholder="e.g. 2.0 (optional)"/>
              <span class="muted">Lower = stricter match</span>
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:12px">
          <div>
            <label>IRL Paint Mode</label>
            <div class="stack">
              <input id="irlMode" type="checkbox"> <span class="muted">Linear‑light preview & target compensation</span>
            </div>
            <div class="stack" style="margin-top:8px">
              <span class="muted">Compensate brightness</span>
              <input id="comp" type="number" min="0.7" max="1.3" step="0.02" value="1.08" style="max-width:140px"/>
              <span class="muted">(try 1.06–1.12)</span>
            </div>
            <div class="stack" style="margin-top:12px">
              <input id="snapEnable" type="checkbox" checked>
              <span class="muted">Snap to nearest default dye if ΔE ≤</span>
              <input id="snapThreshold" type="number" min="0" step="0.1" value="2" style="max-width:100px"/>
            </div>
          </div>
          <div>
            <label>Speed / Search Mode</label>
            <div class="stack" style="flex-wrap:wrap">
              <select id="mode" style="max-width:220px">
                <option value="beam" selected>Beam search (fast)</option>
                <option value="brute">Brute force</option>
              </select>
              <span class="muted">Beam width</span>
              <input id="beam" type="number" min="50" max="2000" step="50" value="200" style="max-width:110px"/>
              <span class="muted">Early stop ΔE ≤</span>
              <input id="early" type="number" min="0" step="0.1" value="1.0" style="max-width:100px"/>
              <label class="stack"><input id="worker" type="checkbox" checked> <span class="muted">Run in background (Web Worker)</span></label>
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:10px">
          <div>
            <div>Recipe Summary</div>
            <div id="summary" class="muted">—</div>
          </div>
          <div class="stack">
            <div class="swatch" id="matchSwatch" title="In‑game match"></div>
            <div>
              <div>In‑game match <code id="matchHex">#—</code> · ΔE <code id="matchDe">—</code></div>
              <div class="muted">(Lower ΔE ≈ closer visual match)</div>
            </div>
          </div>
        </div>

        <div class="pane result" id="result" style="margin-top:10px"></div>
        <footer class="pane">
          In‑game simulation uses Minecraft’s leather‑dye algorithm with brightness normalization (canvas base = white). IRL mode previews linear‑light mixing and lets you compensate the target so the in‑game result appears closer to real paint.
        </footer>
      </div>
    </div>
  </div>

<script>
// ---------- Data (correct to in‑game canvas) ----------
const DYES = {
  black:[0x1D,0x1D,0x21], red:[0xAE,0x2D,0x26], green:[0x5D,0x7B,0x16], brown:[0x81,0x53,0x31],
  blue:[0x3B,0x43,0xA8], purple:[0x87,0x31,0xB6], cyan:[0x16,0x9A,0x9A], light_gray:[0x9B,0x9B,0x95],
  gray:[0x46,0x4E,0x51], pink:[0xF0,0x89,0xA8], lime:[0x7E,0xC5,0x1F], yellow:[0xFB,0xD5,0x3C],
  light_blue:[0x39,0xB1,0xD7], magenta:[0xC5,0x4D,0xBB], orange:[0xF6,0x7E,0x1D], white:[0xFF,0xFF,0xFF]
};
const DYE_NAMES = Object.keys(DYES);
const BASE = [255,255,255]; // white canvas base

// Precompute dye metadata (RGB, max channel, Lab)
const DYE_LIST = DYE_NAMES.map((name)=>{
  const rgb = DYES[name];
  const lab = rgbToLab(rgb);
  const maxc = Math.max(rgb[0], rgb[1], rgb[2]);
  return { name, rgb, lab, maxc };
});

// ---------- Utilities ----------
const clamp255 = v=> v<0?0 : v>255?255 : (v+0.5)|0; // fast round
const floor255 = v=> v<0?0 : v>255?255 : v|0;
const rgbStr = rgb=> `#${rgb.map(x=>x.toString(16).toUpperCase().padStart(2,'0')).join('')}`;
const parseHex = h=>{h=h.trim().replace(/^#/,''); if(h.length===3) h=[...h].map(ch=>ch+ch).join(''); if(h.length!==6) throw new Error('Use #RRGGBB'); return [0,2,4].map(i=>parseInt(h.slice(i,i+2),16)); };

function srgbToLin(c){ c/=255; return c<=0.04045? c/12.92 : Math.pow((c+0.055)/1.055,2.4); }
function linToSrgb(c){ return c<=0.0031308? 12.92*c : 1.055*Math.pow(c,1/2.4)-0.055; }
function rgbToLab([R,G,B]){
  const r=srgbToLin(R), g=srgbToLin(G), b=srgbToLin(B);
  const X=r*0.4124564 + g*0.3575761 + b*0.1804375;
  const Y=r*0.2126729 + g*0.7151522 + b*0.0721750;
  const Z=r*0.0193339 + g*0.1191920 + b*0.9503041;
  const Xn=0.95047, Yn=1.0, Zn=1.08883; const x=X/Xn, y=Y/Yn, z=Z/Zn;
  const f=t=> t>0.008856? Math.cbrt(t) : (7.787*t + 16/116);
  const fx=f(x), fy=f(y), fz=f(z);
  const L=116*fy-16, a=500*(fx-fy), b2=200*(fy-fz);
  return [L,a,b2];
}
const deltaELab = (lab1, lab2)=> Math.hypot(lab1[0]-lab2[0], lab1[1]-lab2[1], lab1[2]-lab2[2]);

function nearestDyeRGB(targetRGB){
  const targetLab = rgbToLab(targetRGB);
  let best=Infinity, name=null, rgb=null;
  for(const d of DYE_LIST){
    const de = deltaELab(targetLab, d.lab);
    if (de < best){ best = de; name = d.name; rgb = d.rgb; }
  }
  return {name, dE: best, rgb};
}

// ---------- Mixing ----------
function mixStepGame(current, dyeNames){
  const cols = [current, ...dyeNames.map(n=>DYES[n])];
  let r=0,g=0,b=0,maxSum=0; const n=cols.length;
  for(let i=0;i<n;i++){ const c=cols[i]; r+=c[0]; g+=c[1]; b+=c[2]; const m=c[0]>c[1]? (c[0]>c[2]?c[0]:c[2]) : (c[1]>c[2]?c[1]:c[2]); maxSum+=m; }
  r/=n; g/=n; b/=n;
  const avgMax = maxSum/n; const maxRGB = (r>g? (r>b?r:b) : (g>b?g:b)) || 1;
  const f = avgMax/maxRGB; r=floor255(r*f); g=floor255(g*f); b=floor255(b*f);
  return [r,g,b];
}
function mixStepLinear(current, dyeNames){
  const cols = [current, ...dyeNames.map(n=>DYES[n])];
  let r=0,g=0,b=0; const n=cols.length;
  for(let i=0;i<n;i++){ const c=cols[i]; r+=srgbToLin(c[0]); g+=srgbToLin(c[1]); b+=srgbToLin(c[2]); }
  r/=n; g/=n; b/=n;
  return [clamp255(linToSrgb(r)*255), clamp255(linToSrgb(g)*255), clamp255(linToSrgb(b)*255)];
}

// ---------- Combinatorics helpers ----------
const NAME_TO_INDEX = Object.fromEntries(DYE_NAMES.map((n,i)=>[n,i]));
function* combosWithReplacement(items, k, start=0, prefix=[]) {
  if(k===0){ yield prefix; return; }
  for(let i=start;i<items.length;i++) yield* combosWithReplacement(items, k-1, i, prefix.concat(items[i]));
}
function keyFromCombo(combo){
  const counts = new Array(DYE_NAMES.length).fill(0);
  for(let i=0;i<combo.length;i++) counts[NAME_TO_INDEX[combo[i]]]++;
  return counts.join(',');
}
const mixMemo = new Map();
function mixStepMemo(base, combo){
  const k = keyFromCombo(combo);
  const hit = mixMemo.get(k);
  if(hit) return hit;
  const out = mixStepGame(base, combo);
  mixMemo.set(k, out);
  return out;
}

// ---------- Searches ----------
function bruteSearch(targetRGB, k1, k2, enableTwo){
  const targetLab = rgbToLab(targetRGB);
  let best=null;
  for(let k=1;k<=k1;k++){
    for(const s1 of combosWithReplacement(DYE_NAMES,k)){
      const out1 = mixStepMemo(BASE, s1);
      let d1 = deltaELab(targetLab, rgbToLab(out1));
      if(!best || d1<best.d){ best={d:d1, steps:[s1], out:out1}; }
      if(enableTwo){
        for(let kB=1;kB<=k2;kB++){
          for(const s2 of combosWithReplacement(DYE_NAMES,kB)){
            const out2 = mixStepGame(out1, s2);
            const d2 = deltaELab(targetLab, rgbToLab(out2));
            if(!best || d2<best.d){ best={d:d2, steps:[s1,s2], out:out2}; }
          }
        }
      }
    }
  }
  return best;
}

function beamSearch(targetRGB, k1, k2, beamWidth=200, earlyStop=1.0, enableTwo=true){
  const targetLab = rgbToLab(targetRGB);
  // Step 1: generate all up to k1 and keep top beamWidth
  let cand1 = [];
  for(let k=1;k<=k1;k++){
    for(const combo of combosWithReplacement(DYE_NAMES,k)){
      const out = mixStepMemo(BASE, combo);
      const d = deltaELab(targetLab, rgbToLab(out));
      cand1.push({combo, out, d});
    }
  }
  cand1.sort((a,b)=>a.d-b.d);
  cand1 = cand1.slice(0, Math.min(beamWidth, cand1.length));
  let best = cand1[0] ? {d:cand1[0].d, steps:[cand1[0].combo], out:cand1[0].out} : null;
  if(!enableTwo) return best;

  // Step 2: expand only top beam
  let cand2Best = null;
  for(const c1 of cand1){
    for(let k=1;k<=k2;k++){
      for(const add of combosWithReplacement(DYE_NAMES,k)){
        const out = mixStepGame(c1.out, add);
        const d = deltaELab(targetLab, rgbToLab(out));
        if(!cand2Best || d < cand2Best.d){
          cand2Best = {d, steps:[c1.combo, add], out};
          if(d <= earlyStop) return cand2Best; // early exit
        }
      }
    }
  }
  return cand2Best || best;
}

// ---------- Web Worker ----------
let WORKER = null;
function ensureWorker(){
  if(WORKER) return WORKER;
  const code = `self.onmessage = function(e){
    const {type, payload} = e.data;
    if(type!=="search") return;
    const {DYES, DYE_NAMES, BASE, target, mode, k1, k2, beamWidth, early, enableTwo} = payload;
    // --- utils duplicated inside worker ---
    const clamp255 = v=> v<0?0 : v>255?255 : (v+0.5)|0;
    function srgbToLin(c){ c/=255; return c<=0.04045? c/12.92 : Math.pow((c+0.055)/1.055,2.4); }
    function linToSrgb(c){ return c<=0.0031308? 12.92*c : 1.055*Math.pow(c,1/2.4)-0.055; }
    function rgbToLab([R,G,B]){ const r=srgbToLin(R), g=srgbToLin(G), b=srgbToLin(B); const X=r*0.4124564 + g*0.3575761 + b*0.1804375; const Y=r*0.2126729 + g*0.7151522 + b*0.0721750; const Z=r*0.0193339 + g*0.1191920 + b*0.9503041; const Xn=0.95047, Yn=1.0, Zn=1.08883; const x=X/Xn, y=Y/Yn, z=Z/Zn; const f=t=> t>0.008856? Math.cbrt(t) : (7.787*t + 16/116); const fx=f(x), fy=f(y), fz=f(z); const L=116*fy-16, a=500*(fx-fy), b2=200*(fy-fz); return [L,a,b2]; }
    const deltaELab=(a,b)=> Math.hypot(a[0]-b[0],a[1]-b[1],a[2]-b[2]);
    const NAME_TO_INDEX = Object.fromEntries(DYE_NAMES.map((n,i)=>[n,i]));
    function* combosWithReplacement(items,k,start=0,prefix=[]){ if(k===0){yield prefix; return;} for(let i=start;i<items.length;i++) yield* combosWithReplacement(items,k-1,i,prefix.concat(items[i])); }
    function mixStepGame(current, dyeNames){ const cols=[current, ...dyeNames.map(n=>DYES[n])]; let r=0,g=0,b=0,maxSum=0; const n=cols.length; for(let i=0;i<n;i++){const c=cols[i]; r+=c[0]; g+=c[1]; b+=c[2]; const m=c[0]>c[1]? (c[0]>c[2]?c[0]:c[2]) : (c[1]>c[2]?c[1]:c[2]); maxSum+=m;} r/=n; g/=n; b/=n; const avgMax=maxSum/n; const maxRGB=(r>g? (r>b?r:b):(g>b?g:b))||1; const f=avgMax/maxRGB; return [Math.max(0,Math.min(255,(r*f)|0)),Math.max(0,Math.min(255,(g*f)|0)),Math.max(0,Math.min(255,(b*f)|0))]; }
    function keyFromCombo(combo){ const counts=new Array(DYE_NAMES.length).fill(0); for(let i=0;i<combo.length;i++) counts[NAME_TO_INDEX[combo[i]]]++; return counts.join(','); }
    const mixMemo=new Map();
    function mixStepMemo(base, combo){ const k=keyFromCombo(combo); const hit=mixMemo.get(k); if(hit) return hit; const out=mixStepGame(base, combo); mixMemo.set(k,out); return out; }
    const targetLab=rgbToLab(target);
    function brute(){ let best=null; for(let k=1;k<=k1;k++){ for(const s1 of combosWithReplacement(DYE_NAMES,k)){ const out1=mixStepMemo(BASE,s1); let d1=deltaELab(targetLab,rgbToLab(out1)); if(!best||d1<best.d){best={d:d1,steps:[s1],out:out1};} if(enableTwo){ for(let kB=1;kB<=k2;kB++){ for(const s2 of combosWithReplacement(DYE_NAMES,kB)){ const out2=mixStepGame(out1,s2); const d2=deltaELab(targetLab,rgbToLab(out2)); if(!best||d2<best.d){best={d:d2,steps:[s1,s2],out:out2};} } } } } } return best; }
    function beam(){ let cand1=[]; for(let k=1;k<=k1;k++){ for(const combo of combosWithReplacement(DYE_NAMES,k)){ const out=mixStepMemo(BASE,combo); const d=deltaELab(targetLab,rgbToLab(out)); cand1.push({combo,out,d}); } } cand1.sort((a,b)=>a.d-b.d); cand1=cand1.slice(0,Math.min(beamWidth,cand1.length)); let best=cand1[0]?{d:cand1[0].d,steps:[cand1[0].combo],out:cand1[0].out}:null; if(!enableTwo) return best; let cand2Best=null; for(const c1 of cand1){ for(let k=1;k<=k2;k++){ for(const add of combosWithReplacement(DYE_NAMES,k)){ const out=mixStepGame(c1.out,add); const d=deltaELab(targetLab,rgbToLab(out)); if(!cand2Best||d<cand2Best.d){ cand2Best={d,steps:[c1.combo,add],out}; if(d<=early) return cand2Best; } } } } return cand2Best||best; }
    const res = (mode==='beam') ? beam() : brute();
    self.postMessage({type:'done', best:res});
  };`;
  const blob = new Blob([code], {type:'application/javascript'});
  WORKER = new Worker(URL.createObjectURL(blob));
  return WORKER;
}

// ---------- Run / Orchestrate ----------
function runSearch(){
  const hex=document.getElementById('hex').value || '#000000';
  const d1=parseInt(document.getElementById('d1').value||'4',10);
  const d2=parseInt(document.getElementById('d2').value||'3',10);
  const enableTwo=document.getElementById('enableTwo').checked;
  const cutoffStr=document.getElementById('deltaCutoff').value;
  const cutoff = cutoffStr? parseFloat(cutoffStr) : null;
  const irl = document.getElementById('irlMode').checked;
  const comp = parseFloat(document.getElementById('comp').value || '1.0');
  const snap = document.getElementById('snapEnable').checked;
  const snapTh = parseFloat(document.getElementById('snapThreshold').value || '2');
  const mode = document.getElementById('mode').value;
  const beamWidth = parseInt(document.getElementById('beam').value||'200',10);
  const early = parseFloat(document.getElementById('early').value||'1.0');
  const useWorker = document.getElementById('worker').checked;

  let target; try{ target=parseHex(hex); }catch(e){ alert(e.message); return; }
  document.getElementById('targetSwatch').style.background=rgbStr(target);

  // Snap to nearest dye (no compensation)
  if(snap){
    const s = nearestDyeRGB(target);
    if(s.dE <= snapTh){
      const best = { d: s.dE, out: s.rgb, steps:[], snapped:true, snapName:s.name, snapDE:s.dE };
      renderBest(best, cutoff);
      return;
    }
  }

  // If IRL mode, pre‑compensate the target in linear space
  if(irl){
    let [R,G,B] = target.map(srgbToLin);
    R = Math.min(1, R*comp); G = Math.min(1, G*comp); B = Math.min(1, B*comp);
    target = [R,G,B].map(v=>clamp255(linToSrgb(v)*255));
  }

  if(useWorker){
    const w = ensureWorker();
    runBtn.disabled=true; runBtn.textContent='Searching…';
    w.onmessage = (e)=>{
      if(e.data && e.data.type==='done'){
        renderBest(e.data.best, cutoff);
        runBtn.disabled=false; runBtn.textContent='Compute Recipe';
      }
    };
    w.postMessage({type:'search', payload:{DYES, DYE_NAMES, BASE, target, mode, k1:d1, k2:d2, beamWidth, early, enableTwo}});
  } else {
    // Local search (beam by default)
    const best = (mode==='beam') ? beamSearch(target, d1, d2, beamWidth, early, enableTwo)
                                 : bruteSearch(target, d1, d2, enableTwo);
    renderBest(best, cutoff);
  }
}

function renderBest(best, cutoff){
  if(!best){ document.getElementById('summary').textContent='No result.'; return; }
  if(cutoff!=null && best.d>cutoff){
    document.getElementById('matchSwatch').style.background='transparent';
    document.getElementById('matchHex').textContent = '#—';
    document.getElementById('matchDe').textContent = `${best.d.toFixed(2)} (> cutoff)`;
    document.getElementById('summary').textContent = `No recipe within ΔE ≤ ${cutoff}. Try increasing search depth or relaxing cutoff.`;
    document.getElementById('result').innerHTML='';
    return;
  }
  document.getElementById('matchSwatch').style.background=rgbStr(best.out);
  document.getElementById('matchHex').textContent=rgbStr(best.out);
  document.getElementById('matchDe').textContent=(best.d||0).toFixed(2);

  let summary = best.steps && best.steps.length? best.steps.map((s,i)=>`Step ${i+1}: ${s.join(', ')}`).join(' → ') : '';
  if(best.snapped){ summary = `Snapped to default dye: ${best.snapName}`; }
  document.getElementById('summary').textContent = summary || '—';

  const result=document.getElementById('result');
  result.innerHTML='';
  if(best.snapped){
    const el=document.createElement('div');
    el.className='step';
    el.innerHTML = `
      <div style="display:flex;align-items:center;gap:12px;justify-content:space-between;flex-wrap:wrap">
        <div style=\"display:flex;align-items:center;gap:12px\"> 
          <div class=\"swatch\" style=\"width:36px;height:36px;background:${rgbStr(best.out)}\" title=\"Default dye\"></div>
          <div><b>Default dye</b>: ${best.snapName} · <code>${rgbStr(best.out)}</code></div>
        </div>
        <div class=\"muted\">no mixing needed</div>
      </div>`;
    result.appendChild(el);
    return;
  }
  let current=BASE;
  (best.steps||[]).forEach((dyes, idx)=>{
    const nextGame = mixStepGame(current, dyes);
    const nextIRL  = mixStepLinear(current, dyes);
    const el=document.createElement('div');
    el.className='step';
    el.innerHTML = `
      <div style="display:flex;align-items:center;gap:12px;justify-content:space-between;flex-wrap:wrap">
        <div style=\"display:flex;align-items:center;gap:12px\"> 
          <div class=\"swatch\" style=\"width:36px;height:36px;background:${rgbStr(nextGame)}\" title=\"In‑game\"></div>
          <div class=\"swatch\" style=\"width:36px;height:36px;background:${rgbStr(nextIRL)}\" title=\"IRL (linear)\"></div>
          <div>
            <div><b>Step ${idx+1}</b> · In‑game <code>${rgbStr(nextGame)}</code> · IRL <code>${rgbStr(nextIRL)}</code></div>
            <div class=\"muted\">Add: ${dyes.map(n=>`<span class='pill'>${n.replace('_',' ')}<\/span>`).join('')}</div>
          </div>
        </div>
        <div class=\"muted\">from ${rgbStr(current)}</div>
      </div>`;
    result.appendChild(el);
    current = nextGame;
  });
}

// ---------- Wire up ----------
const runBtn=document.getElementById('run');
runBtn.addEventListener('click', ()=>{ runBtn.disabled=true; runBtn.textContent='Searching…'; setTimeout(()=>{ runSearch(); runBtn.disabled=false; runBtn.textContent='Compute Recipe'; }, 10); });
window.addEventListener('DOMContentLoaded', ()=>{ try{ runSearch(); }catch{} });
</script>
</body>
</html>
